# OmniFocus 4.7+ Feature Support Implementation Plan

> **For Claude:** Use `/Users/kip/.config/superpowers/skills/skills/collaboration/executing-plans/SKILL.md` to implement
> this plan task-by-task.

**Status:** ðŸŸ¡ Partially Implemented **Updated:** 2025-11-24

**Goal:** Add full OmniFocus 4.7+ feature support (Planned Dates, Mutually Exclusive Tags, Enhanced Repeats) with
LLM-optimized schemas that hide implementation details from end users.

---

## Implementation Status (November 2025)

| Feature                                | Status         | Notes                                                |
| -------------------------------------- | -------------- | ---------------------------------------------------- |
| **Planned Dates**                      | âœ… Implemented | Full support in ManageTaskTool, queries, unified API |
| **Date Schemas Module**                | âœ… Implemented | `src/tools/schemas/date-schemas.ts`                  |
| **Version Detection**                  | âœ… Implemented | Lazy detection with graceful degradation             |
| **Mutually Exclusive Tags**            | âŒ Not Started | Read/toggle functionality on tag groups              |
| **Enhanced Repeats (Intent Keywords)** | âŒ Not Started | "when-marked-done" etc. translation layer            |

**Note:** Current RRULE implementation works well; enhanced repeats are low priority.

---

## Original Design

**Architecture:**

- Planned Dates: New optional date field (third date type alongside Defer/Due)
- Mutually Exclusive Tags: Read/toggle functionality on tag groups
- Enhanced Repeats: User-intent-driven repeat rules (when-marked-done, when-deferred, etc.) that translate internally to
  RRULE + constructor params
- LLM Translation Layer: All OmniFocus 4.7+ internals stay server-side; Claude sees human-friendly intent keywords
- Version Detection: Lazy per-feature detection with graceful degradation on 4.6.1

**Tech Stack:** TypeScript, Zod schemas, JXA + OmniJS bridge, MCP tools

**Approach**: Implement infrastructure-first (Approach 2 from brainstorming). All schemas and translation layer defined
upfront, then scripts follow a consistent pattern.

---

## PHASE 1: SCHEMAS & TRANSLATION LAYER (Infrastructure Foundation)

### Task 1: Create Date Schemas Module

**Files:**

- Create: `src/tools/schemas/date-schemas.ts`

**Step 1: Write the failing test**

```bash
npm test -- tests/unit/tools/schemas/date-schemas.test.ts 2>&1 | head -20
```

Expected: File doesn't exist yet - FAIL

**Step 2: Create the date schemas module**

```typescript
// src/tools/schemas/date-schemas.ts
import { z } from 'zod';

// Reuse existing LocalDateTimeSchema pattern (already works in project)
export const LocalDateTimeSchema = z
  .string()
  .describe(
    'Date and time in YYYY-MM-DD or YYYY-MM-DD HH:mm format (local time). Examples: "2025-03-15", "2025-03-15 14:30"',
  );

// Helper for creating optional date fields with description
export function createDateField(fieldName: string, description: string) {
  return LocalDateTimeSchema.optional().describe(description);
}

// Helper for creating clear date flags
export function createClearDateField(fieldName: string) {
  const capitalizedField = fieldName.charAt(0).toUpperCase() + fieldName.slice(1);
  return z.boolean().optional().describe(`Clear the ${fieldName} (set to null)`);
}

// Export for reuse
export const dateSchemaHelpers = {
  createDateField,
  createClearDateField,
  LocalDateTimeSchema,
};
```

**Step 3: Create companion test file**

```typescript
// tests/unit/tools/schemas/date-schemas.test.ts
import { describe, it, expect } from 'vitest';
import { LocalDateTimeSchema, createDateField, createClearDateField } from '../../../../src/tools/schemas/date-schemas';

describe('Date Schemas', () => {
  it('should validate YYYY-MM-DD format', () => {
    const result = LocalDateTimeSchema.safeParse('2025-03-15');
    expect(result.success).toBe(true);
  });

  it('should validate YYYY-MM-DD HH:mm format', () => {
    const result = LocalDateTimeSchema.safeParse('2025-03-15 14:30');
    expect(result.success).toBe(true);
  });

  it('should allow undefined', () => {
    const result = LocalDateTimeSchema.safeParse(undefined);
    expect(result.success).toBe(true);
  });

  it('should reject invalid formats', () => {
    const result = LocalDateTimeSchema.safeParse('2025-13-45');
    expect(result.success).toBe(false);
  });

  it('createDateField should create optional date field', () => {
    const field = createDateField('dueDate', 'When the task is due');
    const result = field.safeParse('2025-03-15');
    expect(result.success).toBe(true);
  });

  it('createClearDateField should create boolean flag', () => {
    const field = createClearDateField('dueDate');
    const result = field.safeParse(true);
    expect(result.success).toBe(true);
  });
});
```

**Step 4: Run tests**

```bash
npm test -- tests/unit/tools/schemas/date-schemas.test.ts
```

Expected: All 6 tests PASS

**Step 5: Commit**

```bash
git add src/tools/schemas/date-schemas.ts tests/unit/tools/schemas/date-schemas.test.ts
git commit -m "feat: add date schemas module with reusable date field helpers"
```

---

### Task 2: Create Repeat Translation Layer

**Files:**

- Create: `src/omnifocus/scripts/shared/repeat-translation.ts`

**Step 1: Write the failing test**

```bash
npm test -- tests/unit/omnifocus/scripts/repeat-translation.test.ts 2>&1 | head -20
```

Expected: FAIL - file doesn't exist

**Step 2: Create repeat translation module**

```typescript
// src/omnifocus/scripts/shared/repeat-translation.ts

/**
 * Translate user intent (LLM-friendly) to OmniFocus 4.7+ parameters
 * This layer hides RRULE/constructor details from end users
 */

export type AnchorIntent =
  | 'when-deferred' // Start counting from defer date (4.6.1+)
  | 'when-due' // Start counting from due date (4.6.1+) - DEFAULT
  | 'when-marked-done' // Start counting from completion (4.7+)
  | 'planned-date'; // Start counting from planned date (4.7+)

export interface RepeatUserIntent {
  frequency: string; // "every 3 days", "weekly on Monday", etc.
  anchorTo: AnchorIntent; // Where to anchor the repeat
  skipMissed: boolean; // Should we catch up on missed occurrences?
  endCondition?: {
    type: 'never' | 'afterDate' | 'afterOccurrences';
    date?: string; // For afterDate
    count?: number; // For afterOccurrences
  };
}

export interface OmniFocusRepeatParams {
  ruleString: string; // RRULE format: "FREQ=DAILY;INTERVAL=3"
  method: string; // RepetitionMethod: "Fixed" | "DeferUntilDate" | "DueDate"
  scheduleType: string; // RepetitionScheduleType: "Regularly" | "FromCompletion" | "None"
  anchorDateKey: string; // AnchorDateKey: "DeferDate" | "DueDate" | "PlannedDate"
  catchUpAutomatically: boolean; // Should skip missed occurrences
  _source: 'user-intent';
}

/**
 * Map user intent "anchorTo" to OmniFocus internal parameters
 */
export function mapAnchorIntentToOmniFocus(anchorTo: AnchorIntent): {
  anchorDateKey: string;
  method: string;
  scheduleType: string;
  requiresVersion: string | null; // null if 4.6.1 compatible, '4.7' if 4.7+ only
} {
  const mapping: Record<AnchorIntent, any> = {
    'when-deferred': {
      anchorDateKey: 'DeferDate',
      method: 'DeferUntilDate',
      scheduleType: 'FromCompletion',
      requiresVersion: null, // 4.6.1 compatible
    },
    'when-due': {
      anchorDateKey: 'DueDate',
      method: 'Fixed',
      scheduleType: 'Regularly',
      requiresVersion: null, // 4.6.1 compatible
    },
    'when-marked-done': {
      anchorDateKey: 'DueDate', // Fallback for 4.6.1
      method: 'DueDate',
      scheduleType: 'FromCompletion',
      requiresVersion: '4.7', // 4.7+ only (would use DueDate + FromCompletion on older)
    },
    'planned-date': {
      anchorDateKey: 'PlannedDate',
      method: 'Fixed',
      scheduleType: 'Regularly',
      requiresVersion: '4.7', // 4.7+ only
    },
  };

  return mapping[anchorTo];
}

/**
 * Translate user intent to OmniFocus constructor parameters
 */
export function translateRepeatIntent(intent: RepeatUserIntent): OmniFocusRepeatParams {
  const omniFocusParams = mapAnchorIntentToOmniFocus(intent.anchorTo);

  return {
    ruleString: intent.frequency, // In real implementation, convert RRULE format
    method: omniFocusParams.method,
    scheduleType: omniFocusParams.scheduleType,
    anchorDateKey: omniFocusParams.anchorDateKey,
    catchUpAutomatically: intent.skipMissed ?? false,
    _source: 'user-intent',
  };
}
```

**Step 3: Create test file**

```typescript
// tests/unit/omnifocus/scripts/repeat-translation.test.ts
import { describe, it, expect } from 'vitest';
import {
  mapAnchorIntentToOmniFocus,
  translateRepeatIntent,
} from '../../../../src/omnifocus/scripts/shared/repeat-translation';

describe('Repeat Translation Layer', () => {
  describe('mapAnchorIntentToOmniFocus', () => {
    it('should map when-due to DueDate + Regularly (4.6.1 compatible)', () => {
      const result = mapAnchorIntentToOmniFocus('when-due');
      expect(result.anchorDateKey).toBe('DueDate');
      expect(result.scheduleType).toBe('Regularly');
      expect(result.requiresVersion).toBeNull();
    });

    it('should map when-marked-done to 4.7+ params', () => {
      const result = mapAnchorIntentToOmniFocus('when-marked-done');
      expect(result.scheduleType).toBe('FromCompletion');
      expect(result.requiresVersion).toBe('4.7');
    });

    it('should map planned-date to PlannedDate anchor', () => {
      const result = mapAnchorIntentToOmniFocus('planned-date');
      expect(result.anchorDateKey).toBe('PlannedDate');
      expect(result.requiresVersion).toBe('4.7');
    });
  });

  describe('translateRepeatIntent', () => {
    it('should convert user intent to OmniFocus params', () => {
      const intent = {
        frequency: 'FREQ=DAILY;INTERVAL=3',
        anchorTo: 'when-due' as const,
        skipMissed: false,
      };
      const result = translateRepeatIntent(intent);
      expect(result.ruleString).toBe('FREQ=DAILY;INTERVAL=3');
      expect(result.anchorDateKey).toBe('DueDate');
      expect(result.catchUpAutomatically).toBe(false);
    });

    it('should set catchUpAutomatically from skipMissed', () => {
      const intent = {
        frequency: 'FREQ=DAILY',
        anchorTo: 'when-due' as const,
        skipMissed: true,
      };
      const result = translateRepeatIntent(intent);
      expect(result.catchUpAutomatically).toBe(true);
    });
  });
});
```

**Step 4: Run tests**

```bash
npm test -- tests/unit/omnifocus/scripts/repeat-translation.test.ts
```

Expected: All tests PASS

**Step 5: Commit**

```bash
git add src/omnifocus/scripts/shared/repeat-translation.ts tests/unit/omnifocus/scripts/repeat-translation.test.ts
git commit -m "feat: add repeat translation layer - maps user intent to OmniFocus 4.7+ params"
```

---

### Task 3: Update Repeat Schemas with LLM-Friendly Design

**Files:**

- Modify: `src/tools/schemas/repeat-schemas.ts` (add new input schema, keep existing for compatibility)
- Create: `tests/unit/tools/schemas/repeat-schemas-v2.test.ts`

**Step 1: Review current repeat schema**

```bash
grep -A 50 "export const RepeatRuleSchema" src/tools/schemas/repeat-schemas.ts | head -60
```

**Step 2: Update repeat schemas**

Add to `src/tools/schemas/repeat-schemas.ts`:

```typescript
// NEW: User-intent-driven schema (for create/update operations)
export const RepeatRuleUserIntentSchema = z.object({
  frequency: z
    .string()
    .describe(
      'Repeat frequency in human-readable format. Examples: "daily", "every 3 days", "weekly on Monday", "monthly on the 15th", "yearly"',
    ),

  anchorTo: z
    .enum(['when-deferred', 'when-due', 'when-marked-done', 'planned-date'])
    .default('when-due')
    .describe(
      'What date to anchor the repeat to: when-deferred (count from defer), when-due (count from due), when-marked-done (count from completion, 4.7+), planned-date (count from planned, 4.7+)',
    ),

  skipMissed: z.coerce
    .boolean()
    .default(false)
    .describe('Should missed occurrences be skipped (caught up automatically)? Default: false'),

  endCondition: z
    .discriminatedUnion('type', [
      z.object({
        type: z.literal('never').describe('Never end (infinite repeats)'),
      }),
      z.object({
        type: z.literal('afterDate'),
        date: LocalDateTimeSchema.describe('Stop repeating after this date'),
      }),
      z.object({
        type: z.literal('afterOccurrences'),
        count: z.coerce.number().int().positive().describe('Stop after this many occurrences'),
      }),
    ])
    .optional()
    .describe('Optional: When should this repeat end? Omit for infinite repeats'),
});

// For responses/queries - include both user-friendly and technical details
export const RepeatRuleResponseSchema = z.object({
  frequency: z.string(),
  anchorTo: z.string(),
  skipMissed: z.boolean(),
  endCondition: z.any().optional(),

  // Technical details (for advanced users/debugging)
  _details: z
    .object({
      ruleString: z.string().optional(),
      method: z.string().optional(),
      scheduleType: z.string().optional(),
      anchorDateKey: z.string().optional(),
      catchUpAutomatically: z.boolean().optional(),
    })
    .optional()
    .describe('Technical implementation details (for debugging)'),
});
```

**Step 3: Create test for new schema**

```typescript
// tests/unit/tools/schemas/repeat-schemas-v2.test.ts
import { describe, it, expect } from 'vitest';
import { RepeatRuleUserIntentSchema, RepeatRuleResponseSchema } from '../../../../src/tools/schemas/repeat-schemas';

describe('Repeat Schemas - LLM-Optimized', () => {
  describe('RepeatRuleUserIntentSchema', () => {
    it('should validate basic daily repeat', () => {
      const input = {
        frequency: 'daily',
        anchorTo: 'when-due',
        skipMissed: false,
      };
      const result = RepeatRuleUserIntentSchema.safeParse(input);
      expect(result.success).toBe(true);
    });

    it('should use when-due as default anchorTo', () => {
      const input = {
        frequency: 'every 3 days',
      };
      const result = RepeatRuleUserIntentSchema.safeParse(input);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.anchorTo).toBe('when-due');
      }
    });

    it('should use false as default skipMissed', () => {
      const input = {
        frequency: 'weekly',
      };
      const result = RepeatRuleUserIntentSchema.safeParse(input);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.skipMissed).toBe(false);
      }
    });

    it('should validate endCondition with date', () => {
      const input = {
        frequency: 'daily',
        endCondition: {
          type: 'afterDate',
          date: '2025-12-31',
        },
      };
      const result = RepeatRuleUserIntentSchema.safeParse(input);
      expect(result.success).toBe(true);
    });

    it('should validate endCondition with occurrence count', () => {
      const input = {
        frequency: 'daily',
        endCondition: {
          type: 'afterOccurrences',
          count: 10,
        },
      };
      const result = RepeatRuleUserIntentSchema.safeParse(input);
      expect(result.success).toBe(true);
    });

    it('should reject invalid anchorTo values', () => {
      const input = {
        frequency: 'daily',
        anchorTo: 'invalid-anchor',
      };
      const result = RepeatRuleUserIntentSchema.safeParse(input);
      expect(result.success).toBe(false);
    });
  });

  describe('RepeatRuleResponseSchema', () => {
    it('should include user-friendly fields', () => {
      const response = {
        frequency: 'daily',
        anchorTo: 'when-due',
        skipMissed: false,
      };
      const result = RepeatRuleResponseSchema.safeParse(response);
      expect(result.success).toBe(true);
    });

    it('should optionally include technical details', () => {
      const response = {
        frequency: 'daily',
        anchorTo: 'when-due',
        skipMissed: false,
        _details: {
          ruleString: 'FREQ=DAILY',
          method: 'Fixed',
          scheduleType: 'Regularly',
        },
      };
      const result = RepeatRuleResponseSchema.safeParse(response);
      expect(result.success).toBe(true);
    });
  });
});
```

**Step 4: Run tests**

```bash
npm test -- tests/unit/tools/schemas/repeat-schemas-v2.test.ts
```

Expected: All tests PASS

**Step 5: Build to check for TypeScript errors**

```bash
npm run build 2>&1 | grep -i error | head -20
```

Expected: No schema-related errors

**Step 6: Commit**

```bash
git add src/tools/schemas/repeat-schemas.ts tests/unit/tools/schemas/repeat-schemas-v2.test.ts
git commit -m "feat: add LLM-optimized repeat rule schema with user intent design"
```

---

## Summary So Far

**Phase 1 Complete**: Infrastructure foundation for all 4.7+ features

- âœ… Date schemas module (reusable across all date fields)
- âœ… Repeat translation layer (user intent â†’ OmniFocus params)
- âœ… LLM-optimized repeat schemas (human-friendly input, technical details optional)

**Next: Phase 2 - Version Detection System (lazy per-feature detection)**

---

## Would You Like Me To Continue With:

**Option A:** Phase 2 (Version Detection) - define how we detect 4.7+ features lazily **Option B:** Jump to
implementation - show you exactly where/how to use these schemas in create/update scripts **Option C:** Review this
Phase 1 plan before continuing

Which section helps you most?

---

## PHASE 2: VERSION DETECTION & FEATURE FLAGS

### Task 4: Implement Lazy Version Detection

**Files:**

- Create: `src/omnifocus/version-detection.ts`

Detect OmniFocus version and cache feature flags (hasPlannedDates, hasMutuallyExclusiveTags, hasEnhancedRepeats).

---

## PHASE 3: PLANNED DATES SUPPORT

### Task 5-7: Planned Dates in Schemas & Scripts

Update schemas, create-task, update-task, list-tasks, export, and query tools.

---

## PHASE 4: MUTUALLY EXCLUSIVE TAGS

### Task 8: Tag Mutual Exclusivity Support

Update list-tags, manage-tags, and TagsToolV2.

---

## PHASE 5: ENHANCED REPEATS

### Task 9-10: Integrate Translation Layer

Update repeat-helpers, create-task, update-task with translateRepeatIntent().

---

## PHASE 6: TESTING & VALIDATION

### Task 11-12: Integration Tests

Test all 4.7+ features and version compatibility.
