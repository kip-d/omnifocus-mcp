# OmniFocus MCP v2.1.0: Type-Safe Script Execution System

## Overview

v2.1.0 will implement a comprehensive type-safe script execution system based on MCP community best practices research. This addresses the current inconsistent error handling and lack of type safety across the codebase.

## Research Foundation

Based on official MCP TypeScript SDK patterns and community frameworks like FastMCP:
- **Edge validation + typed handlers**: Validate at tool boundaries, keep handlers typed
- **Discriminated unions**: Replace manual error checking with type-safe discrimination
- **Schema validation**: Use Zod (or Standard Schema) for runtime validation
- **Unknown over any**: Eliminate type erasure spread

## Implementation Plan

### Phase 1: Core Type System

#### 1.1 Discriminated Union Types (`src/omnifocus/script-result-types.ts`)
```typescript
type ScriptResult<T = unknown> = 
  | ScriptSuccess<T>
  | ScriptError;

interface ScriptSuccess<T = unknown> {
  success: true;
  data: T;
}

interface ScriptError {
  success: false;
  error: string;
  context?: string;
  details?: unknown;
  stack?: string;
}

// Type guards
function isScriptSuccess<T>(result: ScriptResult<T>): result is ScriptSuccess<T>;
function isScriptError<T>(result: ScriptResult<T>): result is ScriptError;
```

#### 1.2 Enhanced OmniAutomation Class
```typescript
// New executeJson helper with schema validation
public async executeJson<T>(
  script: string, 
  schema?: z.ZodType<T>, 
  context?: string
): Promise<ScriptResult<T>>

// Replace any with unknown
public async executeViaUrlScheme<T = unknown>(script: string): Promise<T>
public async executeBatch<T = unknown>(scripts: string[]): Promise<T[]>
```

#### 1.3 Common Schema Definitions
```typescript
const ProjectResultSchema = z.object({
  id: z.string(),
  name: z.string(),
  note: z.string().optional(),
  dueDate: z.string().nullish(),
  flagged: z.boolean().optional(),
});

const TaskResultSchema = z.object({
  id: z.string(),
  name: z.string(),
  // ...
});

const OperationResultSchema = z.object({
  success: z.boolean(),
  message: z.string().optional(),
  changes: z.array(z.string()).optional(),
});
```

### Phase 2: Tool Migration

#### 2.1 Pattern Example (ProjectsToolV2)
**OLD PATTERN:**
```typescript
const result = await this.omniAutomation.execute<any>(script);
if (!result || result.error) {
  return createErrorResponseV2(/* manual error handling */);
}
// result is any - no type safety
```

**NEW PATTERN:**
```typescript
const result = await this.omniAutomation.executeJson(
  script, 
  ProjectUpdateResultSchema, 
  'project_update'
);

if (isScriptError(result)) {
  return createErrorResponseV2(/* type-safe error */);
}

// TypeScript knows result.data is ProjectUpdateResult
if (!result.data.success) { /* ... */ }
```

#### 2.2 Migration Priority
1. ✅ ProjectsToolV2 (example implementation saved in feature branch)
2. TasksToolV2 (similar pattern)
3. TagsToolV2 
4. Analytics tools
5. Export tools

### Phase 3: Advanced Type Safety

#### 3.1 Enhanced BaseTool Generics
```typescript
BaseTool<TInputSchema, TResponse, TOutputSchema?>
```

#### 3.2 Standard Schema Migration (Optional)
Consider moving from Zod-only to Standard Schema for broader compatibility:
```typescript
import type { InferInput, InferOutput } from '@standard-schema/spec';
```

#### 3.3 ESLint Policy Updates
- Forbid `any` except in designated bridge files
- Enforce `unknown + refinement` pattern
- Per-file overrides for legacy code during migration

## Benefits Expected

### Developer Experience
- ✅ Full TypeScript intellisense and compile-time checking
- ✅ Consistent error handling patterns across all tools
- ✅ Reduced cognitive load (no more scattered error checks)
- ✅ Better debugging with structured error information

### Code Quality
- ✅ Eliminates manual JSON parsing throughout codebase
- ✅ Automatic schema validation with detailed error messages
- ✅ Type-safe error discrimination
- ✅ Follows MCP community best practices

### User Experience
- ✅ More consistent error messages
- ✅ Better error reporting with context
- ✅ No change to external API (internal improvement only)

## Implementation Notes

### Existing Type System Integration
- Current codebase has established type files (`types.ts`, `script-types.ts`)
- New system needs to merge with, not replace, existing patterns
- Gradual migration approach to avoid breaking existing functionality

### Testing Strategy
- Comprehensive unit tests for type guards and discriminated unions
- Integration tests for each migrated tool
- Backwards compatibility validation
- Performance benchmarks (schema validation overhead)

## Branch Strategy

- `feature/type-system-v2.1.0`: Contains initial implementation work
- Implementation should be done in focused PRs:
  1. Core type system
  2. OmniAutomation enhancements  
  3. Tool-by-tool migration
  4. Advanced features

## Success Criteria

1. **Type Safety**: No more `any` types in tool implementations
2. **Consistency**: All tools use same error handling pattern
3. **Performance**: Schema validation overhead <5ms per operation
4. **Backwards Compatibility**: No breaking changes to external API
5. **Test Coverage**: >90% coverage on new type system components

---

**Status**: Planned for v2.1.0 (deferred from v2.0.0 to maintain release schedule)
**Research Complete**: ✅ 
**Proof of Concept**: ✅ (saved in feature branch)
**Ready for Implementation**: ✅